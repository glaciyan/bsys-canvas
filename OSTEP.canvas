{
	"nodes":[
		{"type":"group","id":"85b2461f4596ed9f","x":6560,"y":-6000,"width":4880,"height":3355,"color":"2","label":"Paging"},
		{"type":"group","id":"b4ba49d3acd284d6","x":11040,"y":-200,"width":5200,"height":2360,"color":"2","label":"Segmentation"},
		{"type":"group","id":"501f99fd03d0137f","x":-3040,"y":4428,"width":3704,"height":3024,"color":"2","label":"Limited Direct Execution and Context Switch"},
		{"type":"group","id":"d49956538152b54e","x":2400,"y":4640,"width":2680,"height":3087,"color":"2","label":"Multi-Level Feedback Queue"},
		{"type":"group","id":"b6f834e0cc29110b","x":-2480,"y":538,"width":3680,"height":2222,"color":"2","label":"Process"},
		{"type":"group","id":"293bc3a5583326d6","x":2720,"y":720,"width":2842,"height":2322,"color":"2","label":"Basic Scheduling"},
		{"type":"group","id":"43a71fbca8eb5863","x":-7680,"y":-1492,"width":1524,"height":3554,"color":"6","label":"glibc"},
		{"type":"group","id":"d588f10b617a530e","x":-5120,"y":-1492,"width":1676,"height":2836,"color":"6","label":"Process API"},
		{"type":"group","id":"a4296c5ae3eab4e9","x":-6560,"y":3820,"width":1900,"height":2140,"color":"6","label":"System Calls"},
		{"type":"group","id":"c77fa3b99749eb74","x":8240,"y":-1249,"width":2160,"height":1800,"color":"2","label":"Relocation"},
		{"type":"group","id":"2e60b072308d24fd","x":4562,"y":-1807,"width":2000,"height":1458,"color":"2","label":"Address Space"},
		{"type":"group","id":"196caad14de0f16b","x":6720,"y":-80,"width":1200,"height":1600,"color":"6","label":"Memory API"},
		{"type":"group","id":"ebc6c41c21fd9bf9","x":-8640,"y":-1360,"width":457,"height":666,"label":"Operating System Organization"},
		{"type":"text","text":"# Virtualization\n\nThat is, the OS takes a physical resource (such as the processor, or memory, or a disk) and transforms it into a more general, powerful, and easy-to-use virtual form of itself. Thus, we sometimes refer to the operating system as a virtual machine.","id":"c3ba02e19518acdd","x":-520,"y":-1494,"width":533,"height":228,"color":"2"},
		{"type":"text","text":"# Mechanism (how)\nLow-level methods or protocols that implement a needed piece of functionality. For example: *how does an operating system perform a context switch?*\n\nThe OS needs to share the pysical CPU by **time sharing**.","id":"5ae35fdc96fc34ed","x":-1062,"y":2096,"width":420,"height":290},
		{"type":"text","text":"# Workload (Taskset)\n\nA collective of processes running on a system.","id":"196dfcdbb93b10c2","x":-520,"y":638,"width":420,"height":160},
		{"type":"text","text":"## Job\n\nCurrent CPU burst of a process","id":"7939d7edae8432ec","x":-362,"y":1184,"width":294,"height":127},
		{"type":"text","text":"# Policy (which)\n\nWhich program should the OS run?","id":"4a7a2ce5fc933167","x":-480,"y":1802,"width":312,"height":147},
		{"type":"text","text":"# Process\n\naka. **job**. A running program. Each has a unique name, the **process ID (PID)**","id":"2424515ad2d08de3","x":-1062,"y":1107,"width":373,"height":153},
		{"type":"text","text":"# Checking memory status in Linux\n\nLinux offers a few commands which allow you to check out how it's memory usage looks like.","id":"360a78b7ed2af6ec","x":2148,"y":-1649,"width":647,"height":195},
		{"type":"text","text":"# [pmap](https://man7.org/linux/man-pages/man1/pmap.1.html)\n\nShows detailed usage statistics of a process in virtual address space.\n\nFrom the top the addresses with the program name:\n- `r-x--` executable the top program code\n- `r----` static data\n- `rw---` read write heap start\n\nTODO: `[ anon ]` [read](https://www.redhat.com/sysadmin/pmap-command) because the heap can grow","id":"51dcb14aa87c7829","x":2668,"y":-2024,"width":675,"height":327,"color":"1"},
		{"type":"text","text":"# Virtualizing Memory\nEach process accesses its own *private* **virtual address space** (sometimes just called its **address space**)\n\n```\nprompt> ./mem &; ./mem &\n[1] 24113\n[2] 24114\n(24113) address pointed to by p: 0x200000\n(24114) address pointed to by p: 0x200000\n(24113) p: 1\n(24114) p: 1\n(24114) p: 2\n(24113) p: 2\n(24113) p: 3\n(24114) p: 3\n(24113) p: 4\n(24114) p: 4\n```","id":"63fd3c8afbd6ca97","x":1708,"y":-1355,"width":476,"height":351},
		{"type":"text","text":"# [free](https://man7.org/linux/man-pages/man1/free.1.html)\n\nDisplay amount of free and used memory in the system","id":"2bf491bc31b8e49a","x":1946,"y":-2071,"width":581,"height":180},
		{"type":"text","text":"# Signals\n\nProcess control is available in the form of signals, which can cause jobs to stop, continue, or even terminate.\n\nSome common [standard signals](https://en.wikipedia.org/wiki/C_signal_handling) in C are\n\n- `SIGINT` interrupt a process\n- `SIGTERM` termination request sent to the program\n- `SIGABRT` abnormal termination\n- `SIGSEGV` segmentation fauled, invalid memory access","id":"9a620cdeee512a9d","x":-2400,"y":660,"width":526,"height":325},
		{"type":"text","text":"# Process Termination\n\n## Programmer terminates\n`exit()`\n\n## OS terminates\naccess violation, division by zero, ...\n\n## Another process terminates it\n`kill()` or from shell `kill -0 PID`","id":"cdf8e6a081a12f3d","x":-2356,"y":1065,"width":620,"height":371},
		{"type":"text","text":"# Process Control Block (PCB)\n\naka. process descriptor\n\nA C struct that holds information about an individual process. The struct  holds data like\n\n- start of process memory, and it's size\n- process id (pid)\n- process state\n- parent process\n- open files\n- ...","id":"21c7d1aeb34b0437","x":576,"y":1483,"width":563,"height":417},
		{"type":"text","text":"# States\n\nThose are just a few. Modern OSes have many more States.\n\n## Starting (Initial)\n\n## Ready\n\nThe process can be run by the Kernel.\n\n## Running\n\n## Blocked\n\nThe process is accessing I/O, using a syscall, ...\n\n## Exited (Final, Zombie)\n\nThe process has exited, but has not yet cleaned up. This is useful for other processes (e.g. a shell or parent) to look at the return code.","id":"ea7a4f1ab2a1e129","x":88,"y":638,"width":500,"height":580},
		{"type":"text","text":"# Process List\n\nThe OS keeps track of\n\n- all processes that are ready\n- what process is running\n- processes that are blocked, so when an I/O complete event happens the OS can make further decisions","id":"ab504ee972bf6306","x":-172,"y":1421,"width":520,"height":250},
		{"type":"text","text":"# Scheduling Policy\n\nSometimes called disciplines.\n\nMight use data like\n\n- historical information (which program ran the most?)\n- workload knowledge (what types of programs are run?)\n- performance metrics (is the system optimizing for interactive performance or throughput?)","id":"4c1d9d9e03f47234","x":-68,"y":2226,"width":536,"height":320},
		{"type":"text","text":"# Process Creation Roadmap\n1. Load the program code and any static data into memory. *Early OSes loaded the whole program, but modern OSes only load chunks into memory as they are needed during execution.*\n2. Allocate Memory for the program's (run-time) **stack**. The OS allocates the memory for the process. The OS will also fill in variables like `argc` and `argv`.\n3. Allocate memory for the **heap** which is used by functions like `malloc()` and `free()`. The heap will be small at first but, **as needed, the OS will increase the size**.\n4. Do Registers (see Mechanism/Direct Execution)\n5. The OS will also do initialization for I/O. UNIX systems initialize the stdout, stdin and stderr file descriptors.\n6. Start running the program from `main()`. With that the OS transfers control of the CPU to the new process.","id":"43c3ddb164104564","x":-2269,"y":1530,"width":623,"height":490},
		{"type":"text","text":"# Goals of Virtual Memory (VM)\n\n## Transparency\n\nMore in the sense of *invisible*. Behind the scenes the OS and hardware should do all the work to distribute memory.\n\n## Efficiency\n\nBoth in terms of *speed* and *space*. **For time efficiency the OS has to rely on the hardware**. For space the `struct`s that support VM shouldn't be too big.\n\n## Security\n\n*isolation*\nVM should protect processes  from each other and protect the OS. So a process shouldn't be able to write or read anything from other processes or the OS.","id":"f4b7aee1e4a0cafa","x":2068,"y":-888,"width":505,"height":560},
		{"type":"text","text":"# OS Design Goals\n- Take physical resouces and **virtualize** them\n- Handle tough and tricky issues related to **concurrency**\n- Store files **persistently**, making them safe over the long-term\n\nOne of the most basic goals is to build up some **abstractions** in order to make the system convenient and easy to use.\n\nProvide **high performance** with **minimal overhead**.\n\n## Protection (isolation)\nAnother goal will be to provide **protection** between applications, as well as between the OS and applications\n\n## Reliability\n## Energy-Efficiency\n## Mobility","id":"e81aa252c25b7c82","x":329,"y":-5880,"width":660,"height":560},
		{"type":"text","text":"# Scheduling Metrics\n\nWe differenciate between **performance** metrics and **fairness** metrics. Both fight against each other.","id":"cfa6e85c89954ab7","x":3823,"y":800,"width":456,"height":149},
		{"type":"text","text":"# Machine State\n- what a program can read or update when it is running\n- what parts of the machine are important\n\nPart of the machine state are:\n\n## Memory\nThe memory that the process can access or has it's instructions is part of the process.\n\n## Registers\nSuch as the Program Counter, Stack Pointer, Frame Pointer are all part of and important to the process.\n## Persistence\nFinally, programs often access persistent storage devices too. Information might include a list of the files the process currently has open.","id":"2ba53cb8c295361e","x":-1830,"y":2129,"width":520,"height":571},
		{"type":"text","text":"# Root User (superuser)\n\n- Can access every part of the file system\n- Can control all processes\n- Does not have Kernel access","id":"c00878b2fabe1c1c","x":-2080,"y":-360,"width":440,"height":200},
		{"type":"text","text":"# Virtualizing the CPU\nThe illusion that the system has a very large number of virtual CPUs and allowing many programs to seemingly run at once","id":"95fb3c86d4c7b0f6","x":-1098,"y":40,"width":445,"height":207},
		{"type":"text","text":"# Shortest Job First (SJF)\n\nBetter Turnaround time when shortest job runs first.\n\nBad turnaround when shorter jobs are late.","id":"fd29fd560fbd008a","x":3043,"y":2280,"width":460,"height":160},
		{"type":"text","text":"# Fairness\n\nHow many processes get to run equally long.","id":"5ec28570610decb1","x":3684,"y":1220,"width":368,"height":170},
		{"type":"text","text":"# FIFO\n\nProcesses run first in first out.\n\n## Problems\n\nHorrible Turnaround time when short jobs have to wait for long jobs. (**Convoy Effect**)","id":"eccd8ad4f5dc9a06","x":3343,"y":1802,"width":480,"height":250},
		{"type":"text","text":"## Non-Preemptive\n\nOnly schedule new job when previous job voluntarily relinquishes CPU (performs I/O or exits). Does not change execution order.","id":"4c57d8667ad37e40","x":2740,"y":2052,"width":457,"height":184},
		{"type":"text","text":"## Amortization\n\nFixed Cost operation -> perform it less -> the total cost is reduced.\n\nOptimization of doing something less.","id":"083c12afdd57982e","x":2763,"y":2542,"width":368,"height":210},
		{"type":"text","text":"# Turnaround\n\nFrom arrival to finished.\n\n$T_{turnaround}=T_{completion}-T_{arrival}$","id":"e23cae3f3ff06ee6","x":3970,"y":1650,"width":340,"height":184},
		{"type":"text","text":"# Shortest Time-to-Completion First (STCF)\n\naka. Preemptive Shortest Job First (PSJF), Shortest Remaining Time (SRT)\n\nBe **preemptive** with longer tasks.\n\nThe STCF scheduler determines which of the re-maining jobs (including the new job) has the least time left, and schedules that one.\n\nBad response time.","id":"8b8be7d93ead0124","x":3868,"y":2002,"width":536,"height":395},
		{"type":"text","text":"# Response Time\n\nFrom arrival to first run.\n\n$T_{response}=T_{firstrun}-T_{arrival}$","id":"d2bdd8668aabb1ec","x":4375,"y":1650,"width":361,"height":184},
		{"type":"text","text":"# Waiting Time\nDo not want to spend much time in Ready queue","id":"c031feacc509fa88","x":4814,"y":1727,"width":305,"height":157},
		{"type":"text","text":"# Performance Metrics","id":"ca6701d92e3cce2f","x":4210,"y":1390,"width":388,"height":78},
		{"type":"text","text":"## Being preemptive\n\nPotentially schedule a different job at any point. Changes the order.","id":"feee7abd644766bc","x":4585,"y":2325,"width":418,"height":157},
		{"type":"text","text":"# Round Robbin (RR)\n\nGood response time, fair, bad turnaround time.\n\nSometimes called time-slicing. RR runs a job for a **time slice** (aka. ** scheduling quantum**) and then switches to the next job in the queue.\n\nThe length of a time slice must be a **multiple of the timer-interrupt** period.\n\nIf the timer interrupts every 10 milliseconds, the time slice could be 10, 20, or any other multiple of 10 ms.\n\nYou can optimize RR switching cost by increasing the quantum and doing less context switching (amortization). -> (worse response time)","id":"9e82b080985382ab","x":3303,"y":2622,"width":600,"height":400},
		{"type":"text","text":"# Queue\n\nEach queue is assigned a different **priority level**. Priority is inherently and needs some sort of **unfairness**.\n\n> [!abstract] Rule 1\n> MLFQ uses priorities to decide which job should run at a given time: a job with higher priority (a job on a higher queue) is chosen to run.\n\n> [!abstract] Rule 2\n> When more than one job is on a given queue, use Round-Robin scheduling among those jobs.","id":"c6b159419b34c723","x":3118,"y":5451,"width":500,"height":460},
		{"type":"text","text":"# A new variant of MLFQ\n\n- Only move a task to lower prio when it is preempted\n- When a task becomes ready after I/O: put it back up in the queue where it was before.\n\n","id":"6f4ecf75a2c58ee5","x":2440,"y":5333,"width":450,"height":236},
		{"type":"text","text":"# Observing Jobs\n\nMLFQ changes **priority** of a job based on its *observed behavior*.\n\n1. When a job repeatedly relinquishes the CPU (e.g. waiting for User input), it is assumed to be interactive and MLFQ will keep its priority high.\n2. If a job is running for long periods of time MLFQ will reduce its priority.\n\nThis should create a history of how jobs behaved.","id":"96d87c25a3510683","x":3746,"y":5555,"width":472,"height":356},
		{"type":"file","file":"Notes/Virtualization/Process/Limited Direct Execution and Context Switch/Context-Switch.md","id":"fb879da5ddf35192","x":-120,"y":5162,"width":680,"height":795},
		{"type":"text","text":"# \"C\" Activation Stack\n\nGanz normaler stack, mitten darin wenn sich diese C code läuft hatte sich ein stack aufgebaut, und wärend der läuft es wird unterbrochen\n\nstack von der system funktion","id":"e99cc5e35527e695","x":1220,"y":4953,"width":472,"height":209,"color":"1"},
		{"type":"text","text":"# trapframe\n\nder zustand vom laufenden programm","id":"3b10aee44d3a55ca","x":1220,"y":5230,"width":425,"height":148,"color":"1"},
		{"type":"text","text":"# Kernel State\n\nDie register der CPU ","id":"86f06805ebccb69f","x":1220,"y":5430,"width":376,"height":130,"color":"1"},
		{"type":"text","text":"# Overlap\n\nWhile one process starts doing I/O, work on another process to utilize the CPU while it's waiting for other to finish.","id":"a3fb00f8c77721f1","x":4523,"y":2622,"width":420,"height":180},
		{"type":"text","text":"# Tuning MLFQ\n\nHow to **parameterize** such a scheduler? How many **queues**? How big should the **time slice** be? How often should **priority be boosted**? There are no easy answers to these questions.\n\nSome OSes allow users to give hints to less important processes, in `bash` with the `nice` command.\n\n> [!example]\n> Most MLFQ variants allow for varying time-slice length across different queues.\n> \n> The high-priority queues are usually given short time slices.\n\n> [!info]\n> Some OSes reserve the highest priority exclusively for OS work.","id":"6e58683e17c1533a","x":3618,"y":4747,"width":580,"height":577},
		{"type":"text","text":"# FreeBSD scheduler\n \nUses a **formula to calculate the current priority level** of a job, basing it on **how much CPU the process has used**, in addition, **usage is decayed** over time, providing the desired priority boost in a different manner than described.","id":"fe8cd6688727d37e","x":4399,"y":5124,"width":423,"height":248},
		{"type":"text","text":"## Solaris MLFQ implementation\n\nIt provides a Time-Sharing scheduling class with tables that are easy to configure.\n\n- how the priority of a process is altered throughout its lifetime\n- how long each time slice is\n- how often to boost\n\nDefault values for the table are: 60 queues, slowly increasing time-slice lengths from 20 ms to a few hundred ms, and priorities boosted around every 1 second or so","id":"d90428f333b70431","x":4398,"y":4670,"width":424,"height":388},
		{"type":"text","text":"# The Multi-Level Feedback Queue (MLFQ)\n\nGoals:\n- optimize **turnaround time**\n-  make a system feel responsive to interactive users, minimize **response time**\n\nMLFQ is a system that learns from its past to predict the future. Pay attention to how jobs\nbehave over time and treat them accordingly\n\n> It has **multiple levels** of **queues**, and uses **feedback** to determine the priority of a given job.\n\nOne must be careful with such techniques, as they can easily be wrong and drive a system to make worse decisions than they would have with no knowledge at all. \n","id":"c6f0d7e72aab30b1","x":2460,"y":4700,"width":732,"height":436},
		{"type":"text","text":"# The Problem\n- Implement virtualization with high **performance**\n- The OS should always have some **control over the processes**","id":"c6cdebe19941cafd","x":-2160,"y":4528,"width":496,"height":216},
		{"type":"text","text":"# Time Sharing\n\nThe basic idea is simple: run one process for a little while, then run another one, and so forth.","id":"7202b37186bee4c5","x":-1045,"y":4579,"width":520,"height":165},
		{"type":"text","text":"# Switching Between Processes\n\nThe OS has no direct way of gaining back control of the CPU while something else is running.","id":"a7774b5d2cd7e756","x":-1525,"y":5024,"width":580,"height":192},
		{"type":"text","text":"# Cooperative\n\nWait for system calls. Then decide to run something else.\n\nThe OS trusts the processes to behave reasonably.\n\nMost processes transfer control of the CPU to the OS quite frequently by making:\n1. system calls\n2. `yield` instruction (sometimes in cooperative systems)\n3. Doing something illegal (devide by zero, illegal memory access). This will generate a `trap` and transfer control to OS.\n\nExamples of this kinda of system are:\n- Early versions of the Macintosh OS\n- The old Xerox Alto system\n\n> [!attention]\n> But what if a process never gives up control and runs in a loop? You will have to reboot.\n\n","id":"c88f1f395826e618","x":-1795,"y":5602,"width":560,"height":666},
		{"type":"text","text":"# Non-Cooperative\n\n## Timer interrupt\n\nA timer device hardware can be programmed to *raise an interrupt every so many milliseconds*; when the interrupt is raised, the currently running process is halted, and a pre-configured **interrupt handler** in the OS runs.\n\nUsually an **interrupt handler** does this:\n1. The currently running process is halted.\n2. Save enough of the state of the program.\n3. A pre-configured interrupt handler in the OS runs.\n\n> [!success]\n> A timer interrupt gives OS the ability to run again on a CPU.\n\n> [!note]\n> The OS has to start this timer.\n\n> [!warning]\n> The interrupts are non-deterministic and feel random. Because of the interrupts, normal processes get interrupted (and maybe there isn't anything else to run), and it doesn't run for a little bit -> longer (and sometimes different) runtime.","id":"df725626448e78cc","x":-1089,"y":5437,"width":560,"height":831},
		{"type":"file","file":"Notes/Virtualization/Address Space/Address Space.md","id":"9942cd5a3e45c932","x":4627,"y":-1613,"width":644,"height":503},
		{"type":"text","text":"# Heap\n\nAllocs and Deallocs are done *explicitly* by the **programmer**. With functions like `malloc` and `free`. ","id":"25a0ac869a6d9fb1","x":4986,"y":-589,"width":570,"height":200},
		{"type":"text","text":"# Stack\n\nAllocations and Deallocs are managed *implicitly* by the **compiler**.","id":"e1da1180115d6c63","x":5101,"y":-896,"width":340,"height":160},
		{"type":"text","text":"# [malloc, calloc, realloc, free](https://man7.org/linux/man-pages/man3/malloc.3.html)\n\nallocate and free dynamic memory\n\n`calloc` allocates and zeros the memory\n`realloc` make a new larger region of memory and copy the old region over\n\n> [!bug] Not Allocating Enough Memory\n> \n> ```c\n> char *src = \"hello\";\nchar *dst = (char *) malloc(strlen(src)); // too small!\nstrcpy(dst, src); // work properly\n> ```\n\n> [!bug] Forgetting to Initialize Allocated Memory\n> When you `malloc` and forget to set it to a value and read it. If you do forget, your program will eventually encounter an **uninitialized read**, where it reads from the heap some data of unknown value. Something random and harmful might happen.\n\n> [!bug] Forgetting To Free Memory\n> A **Memory Leak**. Memory leaks will collect over time for long running programs (e.g. OSes) and will eventually lead to running out of memory.\n\n> [!bug] Freeing Memory Before You Are Done With It\n> Sometimes you might free memory before you are done using it. This is called a **dangling pointer**. Might crash your program or overwrite valid memory (if some other `malloc` now owns this memory).\n\n> [!bug] Double Free\n> When you call `free` more than once on the same memory. The MAL might get confused by this and sometimes crash your program or do other weird things. One tactic would be to set your pointers to `NULL` after you freed them.\n\n> [!bug] Invalid frees\n> When you call `free` with something that is not a pointer or e.g. the middle of an array. These error is dangerous.\n\n","id":"1cfb214abeb5fe07","x":6761,"y":-42,"width":681,"height":1220},
		{"type":"text","text":"# valgrind\n\nUse `valgrind` to find memory errors for your running code.","id":"82c880c8f1987027","x":7543,"y":258,"width":340,"height":174},
		{"type":"text","text":"# [mmap](https://man7.org/linux/man-pages/man2/mmap.2.html)\n\nCreate anonymous memory associated with swap space.","id":"283d04409c01b1e2","x":6761,"y":1240,"width":522,"height":180},
		{"type":"text","text":"# Resource Utilization\n\nKeep expensive devices busy","id":"123af79bfbbb6898","x":4814,"y":1344,"width":305,"height":162},
		{"type":"text","text":"# Throughput\nWant many jobs to complete per unit of time","id":"9a6f883bf656f74c","x":5174,"y":1727,"width":305,"height":157},
		{"type":"text","text":"# OS as Memory Manager\n\nThe OS must:\n- keep track of which parts of the memory are free and used\n- setup the hardware so that translations can work  (e.g. by setting registers)\n- maintain control over how memory is being used","id":"822742faa2a11f9c","x":5441,"y":-1753,"width":600,"height":280},
		{"type":"text","text":"# Address Translation\n\nThe idea is to translate a **virtual address** into a **physical address**.\n\nWe make use of **hardware** to be **efficient and secure**. So the name **hardware-based address translation**.\n\nThe hardware transforms each memory access from a **virtual address to a physical address**.","id":"ebea7275816b5b8d","x":5556,"y":-1323,"width":609,"height":294},
		{"type":"text","text":"# Memory-Allocation Library\n\nThe **management of memory is done by the library** ***NOT the OS*** this is why **they are not system calls**. But when there is no more memory to allocate the library will use system calls to request for more. The syscalls are:\n\n- `brk` - change the location of the programs **break**: the location of the end of the heap. This will either decrease or increase the size of the heap.\n- `sbrk` - uses an increment but serves a similar purpose\n\n> [!warning]\n> You should never call `brk` or `sbrk` by yourself. They are used by the MAL, this will confuse it!\n\n","id":"db709177aa5b0672","x":5802,"y":-896,"width":567,"height":486},
		{"type":"text","text":"# Overhead\n\nReduce number of context switches","id":"9a8f807e2027ea35","x":5208,"y":1457,"width":305,"height":156},
		{"type":"text","text":"# Hardware Requirements\n\n|Hardware Requirements|Notes|\n|-|-|\n|Privileged mode|Needed to prevent user-mode processes from executing privileged operations|\n|Base/bounds registers|Need pair of registers per CPU to support address translation and bounds checks|\n|Ability to translate virtual addresses and check if within bounds|Circuitry to do translations and check limits; in this case, quite simple|\n|Privileged instruction(s) to update base/bounds|OS must be able to set these values before letting a user program run|\n|Privileged instruction(s) to register exception handlers|OS must be able to tell hardware what code to run if exception occurs|\n|**Ability to raise exceptions**|When processes try to access privileged instructions or out-of-bounds memory|\n","id":"eb6aadb23ef2f8da","x":8340,"y":-1077,"width":718,"height":500},
		{"type":"text","text":"# Dynamic Hardware Relocation (Base and Limit)\n\nWe make the program believe (transparently) it is at some other position aka. relocation.\n\nTo do this we use 2 hardware registers **base and limit**.\n\nThis can make it easy to move the address space another location.","id":"183b2974b6b5f8dc","x":8797,"y":-312,"width":591,"height":295},
		{"type":"text","text":"# Paging is too slow\n\n1. We have to run a lot more code to get the `PTEAddr`\n2. We have to access memory to get the PTE and it's data\n\n```c\n\n```","id":"7753127ed80322a8","x":8020,"y":-4427,"width":513,"height":307},
		{"type":"text","text":"# Paging\n\nInstead of splitting our memory is *variable sized* pieces which can fragment. We now use **fixed sized** pieces. The biggest advantage would be **flexibility**.\n\nThe main Cons of using paging are:\n1. It's slow\n2. It takes too much memory","id":"ded38139fde28736","x":8788,"y":-4530,"width":461,"height":310},
		{"type":"text","text":"# Free List of Pages\n\nData structure of all free Pages.","id":"5361d530e4d33f56","x":8823,"y":-4821,"width":391,"height":121},
		{"type":"text","text":"# Paging takes too much Memory","id":"92e3e91985959c8f","x":8879,"y":-4039,"width":509,"height":359},
		{"type":"text","text":"# Best Fit\n\n1. Search through the free list\n2. Find the smallest fitting space\n\nTries to reduce wasted space, but is slow because we are going through the entire list and produces a lot of small spaces.","id":"606f8c3bb3ce86b4","x":13978,"y":300,"width":420,"height":240},
		{"type":"text","text":"# Coalescing\n\nWhen memory is freed we look at the neighbours for free space and merge those together into a bigger free space.","id":"b6b7c13517422d93","x":14100,"y":1640,"width":388,"height":212},
		{"type":"text","text":"# Free Space Management","id":"0afd602a516ad989","x":13907,"y":1199,"width":366,"height":113},
		{"type":"text","text":"# Tracking the Size\n\nWe use a header block which sits before the allocated space. It usually contains the size of the allocated space but can also include other things like a magic number (id) for checking if the memory wasn't changed accidentally by something.","id":"66fd6bafa4582d3f","x":14540,"y":1521,"width":498,"height":238},
		{"type":"text","text":"# Size of the free region\n\nThe size of our region is the allocated size + the header size.","id":"675f60f1ff65696a","x":14692,"y":1864,"width":388,"height":176},
		{"type":"text","text":"# Strategies","id":"b389bd8b0c7b2337","x":14273,"y":817,"width":250,"height":60},
		{"type":"text","text":"# Worst Fit\n\nSame but finds to largest space. Tries to leave big chunks free. But its shown to cause excess fragmentation and performs slowly.","id":"bd3b934b59d79d51","x":13978,"y":-80,"width":360,"height":200},
		{"type":"text","text":"# First Fit\n\nUses the first space that is large enough.\n\nSpeedy but fills the beginning with small spaces. One approach is to do address-based ordering so that coalescing becomes easier.","id":"c452dd0006d3ee65","x":14440,"y":20,"width":457,"height":243},
		{"type":"text","text":"# Next Fit\n\nKeeps a pointer of where it was looking last.","id":"4cfb9664e2ae84d0","x":14710,"y":317,"width":357,"height":142},
		{"type":"text","text":"# Embedding a Free List\n\nWhen we have a heap we create a data-structure at the top of our free space. It contains data like:\n- The total free space\n- The next free space pointer\n\nWe also use a `head` pointer for the beginning of the list.","id":"bfe5a5cfb145f461","x":14392,"y":1056,"width":497,"height":286},
		{"type":"text","text":"## Segmentation Fault\n\nArises from a memory access on a segmented machine (sometimes even not segmented) to an illegal address.","id":"babc668b9decf0e4","x":12160,"y":520,"width":442,"height":180},
		{"type":"text","text":"# Compacting\n\nOne solution to external fragmentation is **compacting**. By rearranging (copying) the existing segments to create one big blob.\n\nCompacting is expensive because of all the copying you have to do. It also makes growing existing segments hard to do and may cause another rearrangement.","id":"2e521f4a4084d5c0","x":12684,"y":150,"width":552,"height":294},
		{"type":"text","text":"# Free List Algorithm\n\nFree-list management is a memory allocation technique that maintains **a list of available memory blocks,** or \"free-list,\" for use by programs that request memory allocation. The allocator **searches the free-list for a block of memory that is the appropriate size** to fulfill the request.\n\nSome algorithms are best-fit, worst-fit, first-fit, buddy algorithm,... and many more. There is no great solution for this problem. Those algorithms just minimize it.","id":"66214e9b372b8cd1","x":13312,"y":150,"width":506,"height":333},
		{"type":"text","text":"# Segmentation: Generalized Base/Bounds\n\nOur current problem is the **massive unused space** between **heap and stack**.\n\nOne solution is to **not** have 1 base and limit for an address space, but **segment** an address space into code, heap and stack segments (or other segments) and **give each of them a base and size**.\n\nThis also allows the OS to place each segment into different parts of memory.","id":"e1f1fee65bbe6c9f","x":11512,"y":831,"width":704,"height":306},
		{"type":"text","text":"# Negatively Growing\n\nFor segments (e.g. the stack) which **grows backwards** we add **a boolean bit**.","id":"ae7b55330412dd52","x":12492,"y":1137,"width":384,"height":166},
		{"type":"text","text":"# Translation for Negatively Growing\n\nCalculate the correct **negative offset** we need the **maximum segment size** (sometimes just the limit) $S_{max}$.\n\nNegative offset: $offset_{negative}=offset-S_{max}$ then the physical address is $A_{physical}=offset_{negative}+base$.\n\nThe address is valid when $|offset_{negative}| \\leq size$","id":"36c75faac37d20eb","x":12762,"y":1612,"width":550,"height":345},
		{"type":"text","text":"# Sharing Memory\n\nThis is very useful for **code sharing**.\n\nTo support sharing we need to add **protection bits**, they indicate whether or not a program can read, write or execute memory in a segment.\n\nWhen a code segment is set to **read-execute-only** multiple processes can run that code while each process still thinks that it is accessing its own private memory.","id":"ca20f6b9245bae4d","x":13188,"y":1220,"width":562,"height":317},
		{"type":"text","text":"## Internal Fragmentation\n\nWhen inside the address space we have unused memory.","id":"31b61ed25585201a","x":13653,"y":637,"width":437,"height":180},
		{"type":"text","text":"# Splitting\n\nWhen you take memory from a large block, you don't take the whole thing, just a small part of it.","id":"26097e3fc488592d","x":13740,"y":1620,"width":334,"height":174},
		{"type":"text","text":"# Basic Translation\n\nA segment has a **base and size**. To calculate the physical address from a virtual inside of a segment:\n\n- If the segment is **at the start** of the address space then **the virtual address is the offset** and you can just do an addition with the base $A_{virtual}+base$\n- If the segment **is somewhere else** you have to:\n\t1. Get the **offset** by subtracting the virtual address by the position of the segment in the address space.\n\t2. That offset is now **as if we are at the start**\n\nYou always have to check if this is a valid address when $offset \\leq size$.","id":"63c506a61d938daa","x":12052,"y":1449,"width":526,"height":467},
		{"type":"text","text":"# External Fragmentation\n\nWhen we want to create or grow segments we get a problem called **external fragmentation**.\n\nBy having **many holes in our physical memory** we might be able to satisfy larger memory requests because the next bytes of physical memory are not enough even though **the total free space is enough**.\n\nThis is also a problem for MALs (`malloc`).","id":"b1719b04b87456d5","x":12846,"y":637,"width":623,"height":302},
		{"type":"file","file":"Notes/System Calls/Trap (System Call) Table.md","id":"e228c28d17c8e874","x":-5223,"y":4820,"width":520,"height":540},
		{"type":"text","text":"# Restricted Operations\n\nThe process has no limits on **restricted operations** (I/O, resource access)\n\n## Solution\n\nUsing **protected control transfer** with different **processor modes**:\n\n1. **User mode:** Applications do not have full access to hardware resources.\n2. **Kernel mode:** The OS has access to the full resources of the machine.\n\nThe Kernel can carefully expose certain features which the User can then use with **System calls**.\n\n> [!note]\n> This allows for something like a File System with Permissions.","id":"78c919429064fc6f","x":-3020,"y":6084,"width":580,"height":580},
		{"type":"text","text":"## Breaking the Rule\n\nWhen you try to do I/O (or other restricted operations) in **User mode** the **processor** will result in an **exception**. And then the OS would likely kill the process.","id":"758c471e7b787cfc","x":-2231,"y":6377,"width":422,"height":194},
		{"type":"text","text":"# Limited Direct Execution (LDE) Protocol\n\nThere are 2 Phases to this improved Direct Execution Protocol.\n\n1. The Kernel initializes the **Trap Table**\n2. When running a process, the Kernel sets up a few things (e.g., allocating a node on the process list, allocating memory) before using `return-from-trap` to switch to user mode and start running the program.\n\n|OS @ Boot|Hardware|\n|-|-|\n|initialize trap table||\n||remember address of syscall handler|\n\n|OS @ run (kernel mode)|Hardware|Program (user mode)|\n|-|-|-|\n|Create entry for process list|||\n|Allocate memory for program|||\n|Load program into memory|||\n|Setup user stack with argv|||\n|Fill kernel stack with reg/PC|||\n|`return-from-trap`|||\n||restore regs\n||(from kernel stack)\n||move to user mode\n||jump to main\n|||Run main()\n|||...\n|||Call system call\n|||`trap` into OS\n||save regs\n||(to kernel stack)\n||move to kernel mode\n||jump to trap handler\n|Handle trap|||\n|Do work of syscall|||\n|`return-from-trap`|||\n||restore regs\n||(from kernel stack)\n||move to user mode\n||jump to PC after trap\n|||...\n|||return from main\n|||`trap` (via `exit()`)\n|Free memory of process|||\n|Remove from process list|||","id":"f5461e8be72cf55a","x":-2584,"y":6864,"width":706,"height":568},
		{"type":"text","text":"# \"Freezing\" a Process for later use\n\nFor context-switching to work we need to save several states of our process so we can run it at a later point.\n\n## Trapframe","id":"1c052ce901131132","x":907,"y":5758,"width":404,"height":532},
		{"type":"text","text":"# Den Zustand eines prozesses einfrieren\n\nAlles zusammenfassen","id":"477cde26f43e2ae2","x":1118,"y":6387,"width":762,"height":413,"color":"1"},
		{"type":"text","text":"# Handling Concurrency\n\nThe OS will:\n- **Disable interrupts** during interrupt processing\n- Use a number of sophisticate locking schemes to protect concurrent access to internal data structures.","id":"c3e75942f32abf0d","x":100,"y":6268,"width":494,"height":240},
		{"type":"text","text":"## Turning the Timer off\n\n-> later in concurrency","id":"9a04b74568ce37b2","x":-720,"y":6413,"width":381,"height":122},
		{"type":"text","text":"# Limited Direct Execution Protocol (Timer Interrupt, Context-Switch)\n\n|OS @ Boot|Hardware|\n|-|-|\n|initialize trap table||\n||remember address of syscall handler|\n|start interrupt timer||\n||start timer\n||interrupt CPU in X ms\n\n|OS @ run (kernel mode)|Hardware|Program (user mode)|\n|-|-|-|\n|||Process A\n|||...\n||**timer interrupt**\n||save regs(A) → k-stack(A)\n||move to kernel mode\n||jump to trap handler\n|Handle the trap||\n|Call switch() routine||\n|save regs(A) → proc t(A)||\n|(includes SP to kernel stack)||\n|restore regs(B) ← proc t(B)||\n|switch to k-stack(B) (by loading PCB)||\n|**return-from-trap (into B)**||\n||restore regs(B) ← k-stack(B)\n||move to user mode\n||jump to B’s PC\n|||Process B\n|||...","id":"dc891dc86cb67bd0","x":-1491,"y":6716,"width":771,"height":660},
		{"type":"text","text":"# Interrupt\n\n## Sotware interrupt\n\nTriggered when the PC is on that instruction, synchronous\n\n`SIGINT`, I/O start\n\n## Hardware interrupt\n\nHardware can do it anytime, asynchronous","id":"c54a08b0450d6da2","x":-4236,"y":3721,"width":446,"height":359},
		{"type":"text","text":"# 2 Stacks per Process\n\n**Every** process has 2 different stacks\n\n## User stack\n\n- User code is executed using the normal *\"stack\"* called user stack\n\n## Kernel Stack\n\n- If a trap to a systemcall is done, the code of the OS runs.\n- This OS code is executed using the kernel stack (e.g. `sys_kill()`, `sys_write()`)","id":"c8a3f030b579cf21","x":-6060,"y":5544,"width":597,"height":376},
		{"type":"text","text":"# Wieso in den Kernel Stack\n\nDas gleiche programm kann auf den User stack zugreifen\nwir können zugreifen auf dinge die der kernel gemacht hatte und wissen wo sich der Kernel Stack befindet. Der Kernel Stack wird nicht gelöscht.\n\nWenn man z.b. malloc macht da steht ja schon was drin da können wichtige dinge drin stehen. Deswegen sind die Stacks getrennt.","id":"f861f6ae340a2957","x":-6540,"y":6000,"width":549,"height":340,"color":"1"},
		{"type":"text","text":"# Trap Handler\n\nCode which the OS runs on special events. Jumped to by the hardware with the help of the **Trap Table**","id":"1eb5a69ccea5f4e8","x":-5100,"y":5480,"width":397,"height":184},
		{"type":"text","text":"# Return-from-trap\n\n1. Return into the calling user program\n2. Reduce the privilege level back to user mode","id":"293908f0cbb7a17f","x":-5920,"y":5090,"width":500,"height":153},
		{"type":"text","text":"# Turning off interrupts\n\nUser should't be able to disable interrupts so it won't be able to ignore timer iterrupts","id":"f7671443fe1d893e","x":-6300,"y":4342,"width":411,"height":158,"color":"1"},
		{"type":"text","text":"# Kernel Stack\n\nWhen executing a `trap` the hardware needs to make sure to save the caller's registers (PC, flags, etc.) for it to be able to return from a `return-from-trap` correctly.","id":"4de1549ad6bf09df","x":-6540,"y":5020,"width":480,"height":200},
		{"type":"text","text":"# Jede Task hat ihren eigenen Kernel Stack\n\nhttps://www.google.com/search?client=firefox-b-d&q=every+process+has+its+own+kernel+stack\nJust like there has to be a separate place for each process to hold its set of saved registers (in its process table entry), each process also needs its own kernel stack, to work as its execution stack when it is executing in the kernel.","id":"266ea489995eb1e2","x":-6530,"y":6404,"width":539,"height":289,"color":"1"},
		{"type":"text","text":"# Direct Execution\n\nJust give the Program the CPU and run it directly.\n\n|OS|Program|\n|-|-|\n|1. Create entry for process list||\n|2. Allocate memory for program||\n|3. Load program into memory||\n|4. Set up stack with `argc / argv`||\n|5. Clear registers||\n|6. Execute call `main()`||\n||7. Run `main()`|\n||8. Execute return from `main()`|\n|9. Free memory of process||\n|10. Remove from process list||\n\n## The problems\n\nWithout any *limits* on the running program the OS wouldn't be in control of anything (e.g. kill the program). \"Just a library\"\n","id":"b0a556b5f84d46f0","x":-2680,"y":5117,"width":660,"height":640},
		{"type":"text","text":"# System Calls\n\nBasically the API of the OS. Calls like `open()` or `read()` look like normal procedure calls in C, this is because *they are procedures*. But hidden inside them is the `trap` instruction. The `trap` instruction is provided by the hardware.\n\nThe library which defines calls like `open()` uses an **agreed-upon calling convention with the Kernel**.\n1. It puts the *arguments of the call into well-known locations* (e.g., on the stack, or in specific registers).\n2. It pust the **system-call number** (code) into a well-known location as well.\n3. Execute the `trap` instruction.\n4. Handle return from `trap`.\n5. Give control back to the program.\n\n> [!success]\n> This is **more secure** because the program has to **request** a particular service (here system-call) via number.\n\nThe parts of the C library that make system calls are hand-coded in assembly because they need to execute the hardware-specific trap instruction.","id":"5f99b821dcfca499","x":-5580,"y":3860,"width":600,"height":720},
		{"type":"text","text":"# Trap\n\n*a software interrupt*. Assembly instruction.\n\n1. Interrupts the current process and gives control to the Kernel\n2. Raise priveledge to Kernel mode.","id":"414a36c14254d1af","x":-5900,"y":4740,"width":527,"height":240},
		{"type":"text","text":"# [kill](https://man7.org/linux/man-pages/man2/kill.2.html)\n\nUsed to send a signal to a process. There is also a shell command called `kill`.\n\n> [!danger]\n> When `pid` is -1 the signal is sent to **all processes** for which the process has permission to send that signal.\n\n","id":"dade7a7c57a95af9","x":-3995,"y":-765,"width":420,"height":320},
		{"type":"text","text":"# [signal](https://man7.org/linux/man-pages/man2/signal.2.html)\n\nUsed to handle an incoming signal.","id":"d0fd0d25ca015577","x":-3995,"y":-348,"width":320,"height":120},
		{"type":"text","text":"# [exit](https://man7.org/linux/man-pages/man3/exit.3.html)\n\nCauses normal process termination.","id":"6045d30364b98211","x":-3995,"y":-173,"width":320,"height":140},
		{"type":"text","text":"# Users\n\n## The problem\n\nWho can send a signal to a process, and who cannot? Generally, the systems we use can have multiple people using them at the same time; if one of these people can arbitrarily send signals such as `SIGINT` (to interrupt a process, likely terminating it), the  usability and security of the system will be compromised.\n\n## The user\n\nThe user logs into a system to access resouces.\n\nThe user can launch process and has full control over their own processes (pause them, kill them, etc.).\n\n","id":"8c7db15e32152c6e","x":-2917,"y":-808,"width":740,"height":400},
		{"type":"link","url":"https://pages.cs.wisc.edu/~remzi/OSTEP/","id":"66e9cdc7dc49b077","x":-1447,"y":-6728,"width":732,"height":436},
		{"type":"text","text":"# OS(TEP)\nThe Operating System aka. **Resource Manager**\nIt is just a program written in C.","id":"920166a2ffc4acfc","x":-440,"y":-6240,"width":457,"height":200,"color":"1"},
		{"type":"text","text":"# Concurrency","id":"ab60d046cf8a241b","x":709,"y":-6717,"width":280,"height":70,"color":"5"},
		{"type":"text","text":"# Running a Program\n\nVon Neumann model:\n\n1. Instruction Fetch\n2. Instruction Decode\n3. Execution","id":"29913fa2be0603e2","x":-1295,"y":-6140,"width":420,"height":260},
		{"type":"text","text":"# OS Requirements\n\n|OS Requirements|Notes|\n|-|-|\n|Memory management|Need to allocate memory for new processes; Reclaim memory from terminated processes; Generally manage memory via free list|\n|Base/bounds management|Must set base/bounds properly upon [[Context-Switch]]|\n|Exception handling|Code to run when exceptions arise; likely action is to terminate offending process; Setting the [[Trap (System Call) Table]]|\n\n- When a process is terminated the OS has to reclaim all of its memory for use in other processes or the OS\n- **Save and restore** **base and limit** registers on **context switch**, maybe on the PCB. It can also happen that the OS moves the address space to another location.","id":"d687a10937a9f7a6","x":9231,"y":-1175,"width":595,"height":538},
		{"type":"text","text":"# ASID","id":"1beb041b3f5eef50","x":9019,"y":-5680,"width":328,"height":160},
		{"type":"text","text":"# Page Table\n\n**Per process** data structure to record where each virtual page of the address space is placed in physical memory.\n\nThe simplest for is a *linear page table* which is just an array that the OS indexes with $VPN \\rightarrow PTE$.\n\nThe start is saved in the **Page Table Base Register (PTBR)**.","id":"d0677741a0602f0c","x":9688,"y":-4700,"width":500,"height":300},
		{"type":"text","text":"# Translation Lookaside Buffer (TLB)","id":"458eb9912b83c812","x":9148,"y":-5300,"width":481,"height":145},
		{"type":"text","text":"# Better Accounting (Anti-Gaming)\n\nInstead of forgetting how much of a time slice a process used at a given level, the scheduler should keep track. We create a set **allotment** for each process.\n\nWhether it uses the time slice in one long burst or many small ones does not matter.\n\n> [!abstract] Rule 4\n> Once a job uses up its time allotment at a given level (regardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).","id":"8c1490f20de1e1ff","x":3702,"y":6186,"width":600,"height":440},
		{"type":"text","text":"# Changing Priority V.1\n\n> [!cite] Rule 4a\n> If a job uses up an entire time slice while running, its priority is reduced (i.e., it moves down one queue).\n\n> [!cite] Rule 4b\n> If a job gives up the CPU before the time slice is up, it stays at the same priority level.\n\n## Issues\n\n> [!error] Starvation\n> When there are too many interactive jobs the long running jobs will never get a chance to use the CPU.\n\n> [!bug] Gaming the scheduler\n> Just before a jobs time-slice is over the job issues a very short I/O operation allowing it to remain at the top of the queue allowing it to nearly monopolize the CPU. \n\n> [!warning]\n> A program may change its behavior over time. A long running CPU bound process may start to ask for a lot of I/O.\n\n## A Long-Running Job\n\nWill slowly go down the queues the longer it runs. As Expected.\n\n![[Pasted image 20230327202154.png]]\n\n## Along Came a Short Job\n\nThe Shorter (and late) job will shortly interrupt the long one from running since it has higher priority.\n\n![[Pasted image 20230327202343.png]]\n\n## I/O Jobs\n\nI/O jobs always interrupt the longer one for shorter time and they also stay at the top of the queue.\n\n![[Pasted image 20230327202356.png]]\n\n","id":"afe23a5dcd72b3e1","x":4473,"y":6220,"width":580,"height":980},
		{"type":"text","text":"# Priority Boost\n\n> [!abstract] Rule 5\n>  After some time period S, move all the jobs in the system to the topmost queue.\n\nThus a long running job **won't constantly have to starve** and gets **a chance to issue I/O requests**.\n\nThe variable S is a **voo-doo constant**:\n- It requires from sort of black magic to get right\n- If it is set too high, long-running jobs could starve; too low, and interactive jobs may not get a proper share of the CPU.","id":"096e927c812899d7","x":3702,"y":6764,"width":440,"height":480},
		{"type":"text","text":"## Voo-doo Constants\n\nAvoiding voo-doo constants is a good idea whenever possible. Unfortunately, as in the example above, it is often difficult.\n\n- One could try to make the system learn a good value\n- A configuration file filled with default parameters which an admin can tweak","id":"a55675caf74efbf9","x":3100,"y":6941,"width":413,"height":303},
		{"type":"text","text":"# Initial Priority\n\n> [!abstract] Rule 3\n> When a job enters the system, it is placed at the highest priority (the topmost queue).","id":"6680dc9676a45531","x":3173,"y":6087,"width":390,"height":267},
		{"type":"text","text":"# Persistence","id":"36153968b4065231","x":-766,"y":-7522,"width":250,"height":60,"color":"4"},
		{"type":"text","text":"# Page Table Storage","id":"1821c33ae57db413","x":9751,"y":-5087,"width":375,"height":200,"color":"1"},
		{"type":"text","text":"# Data in Page Table (PTE)\n\n*Page Table Entry*:\n\n- The PFN\n- present bit -> is the page on physical mem or on disk (when it was swapped)\n- valid bit -> whether particular translation is valid, invalid pages are not used physically\n- protection bits -> permissions (read, write, exec)\n- dirty bit -> page has been modified\n- reference bit (accessed bit) -> a page has been accessed, useful for determining popularity\n\nOn Intel there is only a present which is for *valid* and *present*.","id":"bfc7aaa39082d489","x":9751,"y":-4253,"width":450,"height":493},
		{"type":"text","text":"# <u>Virtual Page</u> Number (VPN) and Offset\n\nWhen we have a virtual address it contains the VPN which can be the last few bytes. And the offset which can be the rest.","id":"42d8f92d8581a2c9","x":10368,"y":-4466,"width":424,"height":213},
		{"type":"text","text":"# <u>Physical Frame</u> Number (PFN)\n\nThe physical page number tells us where the memory is located: $Size_{page}*PFN + offset$.","id":"51a4b85f34ac38e8","x":10408,"y":-4057,"width":440,"height":225},
		{"type":"text","text":"# Explicitly Referring To a Segment\n\nTo know which segment is being referred to use the top few bits to differentiate between segments.\n\n![[Pasted image 20230417184033.png]]","id":"36d1db4a6e32f283","x":11495,"y":1577,"width":440,"height":346},
		{"type":"text","text":"# Base Register\n\nThe **base register** is where the OS decides the program should reside in the physical memory.\n\nTo get the physical address we just have to do an **addition**.\n\n`physical address = virtual address + base`","id":"532f436e32012539","x":9680,"y":-453,"width":524,"height":283},
		{"type":"text","text":"# Free List\n\nData structure used to manage free space in the heap or memory.\n\nIt does not need to be a list but just needs a way to keep track of free space.","id":"45eadb9ab231dafd","x":9942,"y":-809,"width":408,"height":246},
		{"type":"text","text":"# Limit (Bounds) Register\n\nThe **limit register** is used for protection, the hardware will make sure the requested address is within that limit.\n\nIf a process generates a virtual address that is greater than the limit, or one that is negative, the **CPU will raise an exception**, calling a trap handler and the process will likely be terminated.","id":"16555231db480eb5","x":9680,"y":-17,"width":524,"height":273},
		{"type":"text","text":"# Buddy Allocation\n\n*designed around making coalescing simple*\n\nWhen a request for memory (needs to be $2^N$) is made, the search for free space recursively divides free space by two until we have a block that is big enough.\n\nWhen we free the Buddy Allocation can recursively go up and **coalesces** 2 blocks into 1.\n\n![[Pasted image 20230425110727.png]]","id":"f498518009b9c116","x":15000,"y":847,"width":540,"height":342},
		{"type":"text","text":"# Segregated Lists\n\nFor popular sized request -> keep a separate just to manage objects of that size. Less fragmentation and faster allocations and frees because we are dedicating memory for objects of similar size.","id":"514400a8e034066c","x":14960,"y":550,"width":470,"height":219},
		{"type":"text","text":"# Static Relocation\n\nAn old and outdated approach where a piece of software called the **loader** took the exec and rewrote all addresses in the assembly.\n\nThis has many problems:\n- no protection against bad addresses\n- it is difficult to move the memory to another location\n\nThis is still used today as locked memory.","id":"10675fa40d5e4625","x":9000,"y":171,"width":520,"height":340},
		{"type":"text","text":"# Fine/Coarse-grained Segmentation\n\n## Coarse\n\nChopping up the address space into big chunks like code, stack, and heap.\n\n## Fine\n\nAn address space consist of many smaller segments.\n\nThis requires further hardware support with a **segment table** stored in memory. These tables support the creation of fine-grained segmentation. This allows the system to use segments in more flexible ways.\n\nThe idea was that the OS could learn which segments are in use and which are not and utilize the main memory more effectively.","id":"2a4f5977ed914c94","x":11337,"y":215,"width":642,"height":457},
		{"type":"text","text":"# Implicit Approach\n\nBecause we are using up bits for differentiating segments, we are losing bits for growing segments. Some systems use an **implicit approach**.\n\nThey do this by noticing how an address was formed, for example by a PC->Code, Stack Pointer->Stack and others are heap.","id":"101491227211c031","x":11200,"y":1220,"width":458,"height":295},
		{"type":"text","text":"## Magic Number\n\n","id":"b508da066057940d","x":15192,"y":1543,"width":348,"height":137,"color":"1"},
		{"type":"text","text":"# [pipe](https://man7.org/linux/man-pages/man2/pipe.2.html)\n\nA pipe is [half-duplex](https://en.wikipedia.org/wiki/Duplex_(telecommunications)) (unidirectional) that means both parties can communicate with each other, but not simultaneously; the communication is one direction at a time.\n\nWhen the read end is empty the process waits for new data. Same with the write end of the pipe when it's full.\n\n`pipefd[0]` is the read end of the pipe. `pipefd[1]` is the write end of the pipe.\n\n## Example\n\n```c\n#define _POSIX_C_SOURCE 1\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\nint main(int argc, char *argv[])\n{\n    int pipefd[2];\n\n    if (pipe(pipefd) == -1)\n    {\n        perror(\"pipe\");\n        exit(1);\n    }\n\n    pid_t rc = fork();\n\n    if (rc < 0)\n    {\n        perror(\"fork\");\n        exit(1);\n    }\n    else if (rc == 0)\n    {\n        // don't need\n        close(pipefd[0]);\n\n        const char *c = \"hello\\n\";\n        write(pipefd[1], c, 6);\n\n        close(pipefd[1]);\n    }\n    else\n    {\n        // don't need\n        close(pipefd[1]);\n\n        char buf;\n        while(read(pipefd[0], &buf, 1) > 0)\n            write(STDOUT_FILENO, &buf, 1);\n\n        close(pipefd[0]);\n    }\n}\n```","id":"fc3455c97bef35ba","x":-7496,"y":760,"width":780,"height":553},
		{"type":"text","text":"# [open](https://man7.org/linux/man-pages/man2/openat.2.html)\n\n```c\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n```\n\nOpens **a handle** and returns **it's number**. (Both will be copied by a fork, so close both)\n\nStarts checking file descriptors starting from 0 (for e.g. opening the fd number of stdout to another file).\n\n## Example\n```c\nconst char *fileName = \"hello.txt\";\nint fd = open(fileName, O_CREAT | O_WRONLY, S_IRWXU);\nif (fd == -1)\n{\n\tperror(fileName);\n\texit(1);\n}\n```\n\n","id":"70681414d49a6c69","x":-7436,"y":-198,"width":720,"height":514},
		{"type":"text","text":"# [dup2](https://man7.org/linux/man-pages/man2/dup.2.html)\n\n```c\nint dup2(int oldfd, int newfd);\n```\n\nThe file descriptor `newfd` is adjusted so that it now refers to the same open file description as `oldfd`.\n\n## Example\n\nWith `dup2` `stdout` refers to the write end. Functions like `printf` will write to the pipe.\n\n```c\n#define _POSIX_C_SOURCE 1\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\nint main(int argc, char *argv[])\n{\n    int pipefd[2];\n\n    if (pipe(pipefd) == -1)\n    {\n        perror(\"pipe\");\n        exit(1);\n    }\n\n    pid_t rc = fork();\n\n    if (rc < 0)\n    {\n        perror(\"fork\");\n        exit(1);\n    }\n    else if (rc == 0)\n    {\n        // don't need\n        close(pipefd[0]);\n\n        dup2(pipefd[1], STDOUT_FILENO);\n        printf(\"hello\\n\");\n\n        close(pipefd[1]);\n    }\n    else\n    {\n        // don't need\n        close(pipefd[1]);\n\n        char buf;\n        while(read(pipefd[0], &buf, 1) > 0)\n            write(STDOUT_FILENO, &buf, 1);\n\n        close(pipefd[0]);\n    }\n}\n```","id":"4163400fff6176fd","x":-7323,"y":1373,"width":607,"height":540},
		{"type":"text","text":"# Slab allocator\n\nWhen the kernel boots up -> allocate some object kernels that are likely to be requested frequently. When a cache is low on memory it requests more memory (slabs) from a more general allocator (e.g. Buddy). The general allocator can also reclaim memory. *Siehe Folien*","id":"f03a356f52412cfe","x":15642,"y":550,"width":478,"height":250},
		{"type":"text","text":"# Redirect output to a file\n```c\n} else if (rc == 0) {\n\t// child: redirect standard output to a file\n\tclose(STDOUT_FILENO);\n\topen(\"./p4.output\", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);\n// ...\n```\n\nThe reason this redirection works is due to an assumption about how the operating system manages file descriptors. Specifically, **UNIX systems start looking for free file descriptors at zero**. In this case, **STDOUT FILENO will be the first available one** and thus get assigned when open() is called.","id":"ee540ebd66d6843d","x":-5906,"y":627,"width":641,"height":350},
		{"type":"text","text":"# Start a process from Scratch\n\n- Load specified code and data into memory; Create empty call stack\n- Create and initialize PCB (make look like context-switch)\n- Put process on ready list\n\nNo wasted work on the system, but it's very difficult to setup.","id":"7b6220f3f4410a90","x":-5906,"y":-1317,"width":659,"height":226},
		{"type":"text","text":"# POSIX I/O\n**Some** of these system calls are routed to the part of the operating system called the **file system**, which then handles the requests and returns some kind of error code to the user.","id":"8586fb4df1051c2b","x":-6780,"y":-520,"width":386,"height":234},
		{"type":"text","text":"# [write](https://man7.org/linux/man-pages/man2/write.2.html)","id":"9a8596ec28b00cf6","x":-6966,"y":522,"width":250,"height":60},
		{"type":"text","text":"# [close](https://man7.org/linux/man-pages/man2/close.2.html)","id":"9a1cc8c52185ee10","x":-6966,"y":642,"width":250,"height":60},
		{"type":"text","text":"# [read](https://man7.org/linux/man-pages/man2/read.2.html)","id":"afd24405aed79ccb","x":-6966,"y":402,"width":250,"height":60},
		{"type":"text","text":"# [syscalls](https://man7.org/linux/man-pages/man2/syscalls.2.html)\n\nglibc has wrappers around syscalls which\n- copy arguments and the unique system call number to the registers or stacks where the kernel expects them\n- `trap` to kernel mode, at which point the kernel does the real work of the system call\n- set _[errno](https://man7.org/linux/man-pages/man3/errno.3.html)_ if the system call returns an error number when the kernel returns the CPU to user mode\n\nMore details -> System Calls","id":"ecb34cf7e32bc8ed","x":-7000,"y":-980,"width":530,"height":340},
		{"type":"text","text":"# glibc\nThe GNU C standard library for Linux. Resides in **User Space**.\n\n","id":"c10e81ad61295a5f","x":-6780,"y":-1360,"width":360,"height":166},
		{"type":"text","text":"# How the shell executes a program\n- calls `fork` to create a new child process\n- `exec` to run the command\n- `wait` for it to finish","id":"4b7760bd5946ac36","x":-5715,"y":164,"width":441,"height":220},
		{"type":"text","text":"# [exec family](https://man7.org/linux/man-pages/man3/exec.3.html)\n\n`exec()` replaces the code of the current process. It is useful when you want to run a different program. Given the name of an executable and some args, it `loads` the code from that exec and **overwrites** the code currently running the process. The heap, stack and other parts of its memory are re-initialized.\n\n**A success full call to `exec` will never return!** This is because it overwrites the original code.\n\nThe variants of `exec` are `execl`, `execlp`, `execle`, `execv`, `execvp`, and `execvpe`.\n\n## L&V family\n\nThe L family uses many arguments to construct argc. `const char *arg, ...` the last argument has to be the NULL terminator `(char *) NULL`.\n\nThe V family uses an array. `char *const argv[]`. The array of pointers _must_ be terminated by a null pointer.\n\n## P Flag\nWith p `exec` search the `PATH` for the executable. Otherwise you have to give the full path.\n\n## E Flag\n\nAllows you to give custom Environment Variables.","id":"b2e7fb0923e7617a","x":-5015,"y":473,"width":660,"height":556},
		{"type":"text","text":"# Process API\n## Create\n## Destroy\n## Wait\n## Misc Control\n- suspend a process\n- resume a process\n## Status\n- how long has a process run\n- what state is it in","id":"4c906fb755fd1076","x":-4480,"y":-1380,"width":465,"height":462},
		{"type":"text","text":"# [fork](https://man7.org/linux/man-pages/man2/fork.2.html#top_of_page)\n\nCreate a new process. A copy and child of the calling processes code, data, stack, and PCB, both about to return from `fork`. **The copy of the PCB is then put onto the ready process list.** The child has\n\n- its own copy of the **address space**, **registers** and **program counter**\n- all file handles are copied over\n\nThe child process with return from `fork` with a 0. The parent process will get the pid of the child process.\n\n## Example\n\n```c\n#define _POSIX_C_SOURCE 1\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(void)\n{\n    int x = 100;\n    printf(\"i am (pid:%jd) x:%d\\n\", (intmax_t) getpid(), x);\n    intmax_t rc = fork();\n\n    if (rc < 0)\n    {\n        fprintf(stderr, \"fork failed\\n\");\n        exit(1);\n    }\n    else if (rc == 0)\n    {\n        x = 200;\n        printf(\"hello i am child process (pid:%jd) x:%d\\n\", (intmax_t) getpid(), x);\n    }\n    else\n    {\n        x = 150;\n        printf(\"i am the parent of %jd (pid:%jd) x:%d\\n\", rc, (intmax_t) getpid(), x);\n    }\n\n    return 0;\n}\n```","id":"209805b1d910bca2","x":-5015,"y":-647,"width":660,"height":544},
		{"type":"text","text":"# [wait/waitpid](https://man7.org/linux/man-pages/man2/wait.2.html#top_of_page)\n\nThe parent process calls `wait()` to delay its execution until the child finishes executing. When the child is done, `wait()` returns to the parent.\n\n## Example\n\n```c\n#define _POSIX_C_SOURCE 1\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(void)\n{\n    pid_t rc = fork();\n\n    if (rc < 0)\n    {\n        fprintf(stderr, \"fork failed\\n\");\n        exit(1);\n    }\n    else if (rc == 0)\n    {\n        // child here\n        printf(\"hello i am child\\n\");\n    }\n    else\n    {\n        // parent\n        intmax_t rc_wait = wait(NULL);\n        printf(\"goodbye rc_wait:%jd\\n\", rc_wait);\n    }\n}\n```","id":"9cd824eb85bbe36b","x":-5015,"y":-16,"width":660,"height":420},
		{"type":"text","text":"# [getpid](https://man7.org/linux/man-pages/man2/getpid.2.html)\n\nReturns the process ID (PID) of the calling process. **These functions are always successful.**","id":"c7fe7afd0762ce72","x":-3995,"y":-8,"width":320,"height":172},
		{"type":"text","text":"# User Space\n- Runs the programs","id":"07d57b69a726b53e","x":-8563,"y":-1304,"width":300,"height":120},
		{"type":"text","text":"# Kernel","id":"f1428a4c919dc493","x":-8538,"y":-1084,"width":250,"height":60},
		{"type":"text","text":"## Drivers\nignores all security","id":"1340d79536ebd284","x":-8538,"y":-1014,"width":250,"height":107},
		{"type":"text","text":"## Hardware","id":"a494ee197cac932c","x":-8538,"y":-804,"width":250,"height":60},
		{"type":"text","text":"# Time sharable\ne.g. time-sharing the CPU","id":"086c005cc5d03f37","x":-9142,"y":-926,"width":322,"height":152},
		{"type":"text","text":"# Space sharable\ne.g. memory, disc sharing","id":"ec1c399fbd4ee5ed","x":-9142,"y":-720,"width":322,"height":140},
		{"type":"text","text":"# File descriptor","id":"2bdd4bc57a945fe7","x":-847,"y":-7840,"width":415,"height":75}
	],
	"edges":[
		{"id":"0ec1a2c6ed31c6cb","fromNode":"07d57b69a726b53e","fromSide":"bottom","toNode":"f1428a4c919dc493","toSide":"top","toEnd":"none"},
		{"id":"ee96446505b0514c","fromNode":"f1428a4c919dc493","fromSide":"bottom","toNode":"1340d79536ebd284","toSide":"top","toEnd":"none"},
		{"id":"a684ba18bb4ff819","fromNode":"1340d79536ebd284","fromSide":"bottom","toNode":"a494ee197cac932c","toSide":"top","toEnd":"none"},
		{"id":"2da0a989af7fbba9","fromNode":"07d57b69a726b53e","fromSide":"right","toNode":"c10e81ad61295a5f","toSide":"left"},
		{"id":"366af27d8bb603fd","fromNode":"920166a2ffc4acfc","fromSide":"bottom","toNode":"c3ba02e19518acdd","toSide":"top"},
		{"id":"117397c5ac2bff7c","fromNode":"c10e81ad61295a5f","fromSide":"bottom","toNode":"ecb34cf7e32bc8ed","toSide":"top"},
		{"id":"740896196a3b1464","fromNode":"f1428a4c919dc493","fromSide":"right","toNode":"ecb34cf7e32bc8ed","toSide":"left"},
		{"id":"bbdd04c8dabd08a7","fromNode":"c3ba02e19518acdd","fromSide":"bottom","toNode":"95fb3c86d4c7b0f6","toSide":"top"},
		{"id":"d29970d1355f3582","fromNode":"95fb3c86d4c7b0f6","fromSide":"bottom","toNode":"2424515ad2d08de3","toSide":"top"},
		{"id":"cffde2fbf89af2eb","fromNode":"c10e81ad61295a5f","fromSide":"right","toNode":"4c906fb755fd1076","toSide":"left"},
		{"id":"6bf791e88fcd3b6d","fromNode":"2424515ad2d08de3","fromSide":"left","toNode":"4c906fb755fd1076","toSide":"right"},
		{"id":"2c8cfe8428617fa3","fromNode":"2424515ad2d08de3","fromSide":"bottom","toNode":"4a7a2ce5fc933167","toSide":"left"},
		{"id":"da3d6d4237afa8b7","fromNode":"2424515ad2d08de3","fromSide":"bottom","toNode":"5ae35fdc96fc34ed","toSide":"top"},
		{"id":"aa910e5c55148335","fromNode":"29913fa2be0603e2","fromSide":"right","toNode":"920166a2ffc4acfc","toSide":"left"},
		{"id":"cf1f4892bb35b5a6","fromNode":"920166a2ffc4acfc","fromSide":"right","toNode":"ab60d046cf8a241b","toSide":"left"},
		{"id":"141c6033ce14bcea","fromNode":"c3ba02e19518acdd","fromSide":"bottom","toNode":"63fd3c8afbd6ca97","toSide":"left"},
		{"id":"88f308ef6a48998b","fromNode":"920166a2ffc4acfc","fromSide":"top","toNode":"36153968b4065231","toSide":"bottom"},
		{"id":"a76b9c83264d753d","fromNode":"66e9cdc7dc49b077","fromSide":"right","toNode":"920166a2ffc4acfc","toSide":"left"},
		{"id":"74beb78c842b2ced","fromNode":"c10e81ad61295a5f","fromSide":"right","toNode":"8586fb4df1051c2b","toSide":"right"},
		{"id":"4d1367148e991346","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"70681414d49a6c69","toSide":"right"},
		{"id":"6fc2684db998427b","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"afd24405aed79ccb","toSide":"right"},
		{"id":"808e4c038c3d0fe8","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"9a8596ec28b00cf6","toSide":"right"},
		{"id":"3e8ef472878b787b","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"9a1cc8c52185ee10","toSide":"right"},
		{"id":"ee58952586617de2","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"fc3455c97bef35ba","toSide":"right"},
		{"id":"65cfd89bed293402","fromNode":"dade7a7c57a95af9","fromSide":"bottom","toNode":"d0fd0d25ca015577","toSide":"top"},
		{"id":"210d7362c90c5df2","fromNode":"920166a2ffc4acfc","fromSide":"bottom","toNode":"e81aa252c25b7c82","toSide":"left"},
		{"id":"751485bb7292fe55","fromNode":"4a7a2ce5fc933167","fromSide":"right","toNode":"4c1d9d9e03f47234","toSide":"top"},
		{"id":"1331a43f501fed6d","fromNode":"2424515ad2d08de3","fromSide":"bottom","toNode":"2ba53cb8c295361e","toSide":"top"},
		{"id":"17e165fc058ed1e8","fromNode":"2424515ad2d08de3","fromSide":"right","toNode":"ea7a4f1ab2a1e129","toSide":"left"},
		{"id":"f73f808784d83aee","fromNode":"8586fb4df1051c2b","fromSide":"bottom","toNode":"4163400fff6176fd","toSide":"right"},
		{"id":"15977132bb4bad8e","fromNode":"2424515ad2d08de3","fromSide":"left","toNode":"43c3ddb164104564","toSide":"right"},
		{"id":"6cad222c118cd7ba","fromNode":"36153968b4065231","fromSide":"top","toNode":"2bdd4bc57a945fe7","toSide":"bottom"},
		{"id":"b529040dd9eff34d","fromNode":"ab504ee972bf6306","fromSide":"right","toNode":"21c7d1aeb34b0437","toSide":"left"},
		{"id":"801ecaa6db8df524","fromNode":"2424515ad2d08de3","fromSide":"right","toNode":"ab504ee972bf6306","toSide":"left"},
		{"id":"eca92005eb5a170c","fromNode":"21c7d1aeb34b0437","fromSide":"top","toNode":"ea7a4f1ab2a1e129","toSide":"bottom"},
		{"id":"a0b7e7c6cadba3a0","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"209805b1d910bca2","toSide":"right"},
		{"id":"8e6573e351e240bf","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"9cd824eb85bbe36b","toSide":"right"},
		{"id":"ecc6a7c1afd59a3f","fromNode":"b2e7fb0923e7617a","fromSide":"left","toNode":"4b7760bd5946ac36","toSide":"right"},
		{"id":"0c57a1696f2847d3","fromNode":"209805b1d910bca2","fromSide":"left","toNode":"4b7760bd5946ac36","toSide":"right"},
		{"id":"2a62a3c08aa55041","fromNode":"9cd824eb85bbe36b","fromSide":"left","toNode":"4b7760bd5946ac36","toSide":"right"},
		{"id":"627b39add3cf491b","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"b2e7fb0923e7617a","toSide":"right"},
		{"id":"335abca4a74967f9","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"dade7a7c57a95af9","toSide":"left"},
		{"id":"0419512e52cbeeba","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"d0fd0d25ca015577","toSide":"left"},
		{"id":"070fd2211b803ff2","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"6045d30364b98211","toSide":"left"},
		{"id":"81ed564da5c78e9f","fromNode":"4b7760bd5946ac36","fromSide":"bottom","toNode":"ee540ebd66d6843d","toSide":"top"},
		{"id":"04ef5cca2054d023","fromNode":"8c7db15e32152c6e","fromSide":"right","toNode":"c00878b2fabe1c1c","toSide":"top"},
		{"id":"31b7a2a350be584c","fromNode":"8c7db15e32152c6e","fromSide":"bottom","toNode":"2424515ad2d08de3","toSide":"top"},
		{"id":"94306d3059d67f4a","fromNode":"d0fd0d25ca015577","fromSide":"right","toNode":"9a620cdeee512a9d","toSide":"left"},
		{"id":"9dfec50ede757568","fromNode":"2424515ad2d08de3","fromSide":"left","toNode":"9a620cdeee512a9d","toSide":"right"},
		{"id":"ad89e9949b2b76e7","fromNode":"7b6220f3f4410a90","fromSide":"bottom","toNode":"209805b1d910bca2","toSide":"top"},
		{"id":"df684c05357b9210","fromNode":"4c906fb755fd1076","fromSide":"bottom","toNode":"c7fe7afd0762ce72","toSide":"left"},
		{"id":"f22749f2ccad4fd4","fromNode":"2424515ad2d08de3","fromSide":"left","toNode":"cdf8e6a081a12f3d","toSide":"right"},
		{"id":"5f7e571aad19defe","fromNode":"cdf8e6a081a12f3d","fromSide":"left","toNode":"6045d30364b98211","toSide":"right"},
		{"id":"72c9fe4bcf028e62","fromNode":"cdf8e6a081a12f3d","fromSide":"left","toNode":"dade7a7c57a95af9","toSide":"right"},
		{"id":"a2dc01757405e051","fromNode":"e228c28d17c8e874","fromSide":"bottom","toNode":"1eb5a69ccea5f4e8","toSide":"top"},
		{"id":"b20452cfc48a9932","fromNode":"cfa6e85c89954ab7","fromSide":"bottom","toNode":"ca6701d92e3cce2f","toSide":"top"},
		{"id":"0433a2536f26872e","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"e23cae3f3ff06ee6","toSide":"top"},
		{"id":"d29e9f674590fc27","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"d2bdd8668aabb1ec","toSide":"top"},
		{"id":"126f9f140875c756","fromNode":"5ae35fdc96fc34ed","fromSide":"bottom","toNode":"c6cdebe19941cafd","toSide":"top"},
		{"id":"6d1114ce518bd4e8","fromNode":"a494ee197cac932c","fromSide":"left","toNode":"086c005cc5d03f37","toSide":"right"},
		{"id":"bd50c0b458298124","fromNode":"a494ee197cac932c","fromSide":"left","toNode":"ec1c399fbd4ee5ed","toSide":"right"},
		{"id":"93dcca7d8c31ea70","fromNode":"5ae35fdc96fc34ed","fromSide":"bottom","toNode":"7202b37186bee4c5","toSide":"left"},
		{"id":"0becad79b6a94f62","fromNode":"7202b37186bee4c5","fromSide":"bottom","toNode":"fb879da5ddf35192","toSide":"left"},
		{"id":"c4edb758d2a84172","fromNode":"78c919429064fc6f","fromSide":"left","toNode":"5f99b821dcfca499","toSide":"right"},
		{"id":"49346fe6eabafa34","fromNode":"b0a556b5f84d46f0","fromSide":"bottom","toNode":"78c919429064fc6f","toSide":"top","label":"Problem 1"},
		{"id":"10ba6ab307a815f7","fromNode":"c6cdebe19941cafd","fromSide":"bottom","toNode":"b0a556b5f84d46f0","toSide":"top","label":"Basic Technique"},
		{"id":"22b0e4e620ec7e15","fromNode":"b0a556b5f84d46f0","fromSide":"right","toNode":"a7774b5d2cd7e756","toSide":"left","label":"Problem 2"},
		{"id":"016a36fdf3a2115e","fromNode":"5f99b821dcfca499","fromSide":"bottom","toNode":"414a36c14254d1af","toSide":"top"},
		{"id":"26d8f0a25d3e3018","fromNode":"5f99b821dcfca499","fromSide":"bottom","toNode":"e228c28d17c8e874","toSide":"top"},
		{"id":"c86aeec91671cf1c","fromNode":"ecb34cf7e32bc8ed","fromSide":"right","toNode":"5f99b821dcfca499","toSide":"top","color":"#7ed79c"},
		{"id":"190274d5697fd6cd","fromNode":"ecb34cf7e32bc8ed","fromSide":"bottom","toNode":"8586fb4df1051c2b","toSide":"top"},
		{"id":"0f2729a609e6ec0f","fromNode":"414a36c14254d1af","fromSide":"bottom","toNode":"293908f0cbb7a17f","toSide":"top"},
		{"id":"c23139067f9f931b","fromNode":"414a36c14254d1af","fromSide":"right","toNode":"e228c28d17c8e874","toSide":"left"},
		{"id":"886a76f0f1b249c5","fromNode":"414a36c14254d1af","fromSide":"left","toNode":"4de1549ad6bf09df","toSide":"top"},
		{"id":"2dcf6601f5c81f69","fromNode":"4de1549ad6bf09df","fromSide":"right","toNode":"293908f0cbb7a17f","toSide":"left"},
		{"id":"c8244de34efbf6bc","fromNode":"78c919429064fc6f","fromSide":"bottom","toNode":"f5461e8be72cf55a","toSide":"top","label":"Solved"},
		{"id":"d5741f5dcbf70265","fromNode":"a7774b5d2cd7e756","fromSide":"bottom","toNode":"c88f1f395826e618","toSide":"top"},
		{"id":"2705cc0eaebf3cc4","fromNode":"a7774b5d2cd7e756","fromSide":"bottom","toNode":"df725626448e78cc","toSide":"top"},
		{"id":"66ec5e668b5878c3","fromNode":"df725626448e78cc","fromSide":"bottom","toNode":"9a04b74568ce37b2","toSide":"top"},
		{"id":"6f615e31b127ebcd","fromNode":"7202b37186bee4c5","fromSide":"bottom","toNode":"df725626448e78cc","toSide":"top"},
		{"id":"ab7506fa29661d7a","fromNode":"fb879da5ddf35192","fromSide":"top","toNode":"4c1d9d9e03f47234","toSide":"bottom"},
		{"id":"9dfbbb2dcd1e3982","fromNode":"df725626448e78cc","fromSide":"right","toNode":"fb879da5ddf35192","toSide":"left"},
		{"id":"e772a20b6c8bf88c","fromNode":"f5461e8be72cf55a","fromSide":"right","toNode":"dc891dc86cb67bd0","toSide":"left"},
		{"id":"0df012f9b7f44976","fromNode":"fb879da5ddf35192","fromSide":"bottom","toNode":"dc891dc86cb67bd0","toSide":"right"},
		{"id":"e2954d902e8b29ea","fromNode":"78c919429064fc6f","fromSide":"left","toNode":"c8a3f030b579cf21","toSide":"right"},
		{"id":"676977238b782c94","fromNode":"4de1549ad6bf09df","fromSide":"bottom","toNode":"c8a3f030b579cf21","toSide":"top"},
		{"id":"9b637d42caa21bc2","fromNode":"fb879da5ddf35192","fromSide":"bottom","toNode":"c3e75942f32abf0d","toSide":"top"},
		{"id":"fe42fdf402aa0664","fromNode":"4c1d9d9e03f47234","fromSide":"right","toNode":"cfa6e85c89954ab7","toSide":"left"},
		{"id":"64d95bb4a7e9fa47","fromNode":"2424515ad2d08de3","fromSide":"right","toNode":"196dfcdbb93b10c2","toSide":"bottom"},
		{"id":"2a93564bb68f8f06","fromNode":"cfa6e85c89954ab7","fromSide":"bottom","toNode":"5ec28570610decb1","toSide":"top"},
		{"id":"3e9aa65b610aa2a0","fromNode":"4c1d9d9e03f47234","fromSide":"right","toNode":"eccd8ad4f5dc9a06","toSide":"left","label":"We known how long\nthe program is"},
		{"id":"7600e5ac14c475a3","fromNode":"eccd8ad4f5dc9a06","fromSide":"bottom","toNode":"fd29fd560fbd008a","toSide":"top","label":"Have different\nlengths"},
		{"id":"9c1f7a2ea492692d","fromNode":"fd29fd560fbd008a","fromSide":"right","toNode":"8b8be7d93ead0124","toSide":"left","label":"Start at different\ntimes"},
		{"id":"dc7c44d4572eedc2","fromNode":"8b8be7d93ead0124","fromSide":"bottom","toNode":"9e82b080985382ab","toSide":"top","label":"Now we care about\nresponse time"},
		{"id":"941d51777254c015","fromNode":"9e82b080985382ab","fromSide":"left","toNode":"083c12afdd57982e","toSide":"right"},
		{"id":"f80d16ab5f731890","fromNode":"9e82b080985382ab","fromSide":"right","toNode":"a3fb00f8c77721f1","toSide":"left","label":"Now with I/O"},
		{"id":"b42ba4995d24632c","fromNode":"2424515ad2d08de3","fromSide":"right","toNode":"7939d7edae8432ec","toSide":"left"},
		{"id":"de7c26a87c1480f7","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"123af79bfbbb6898","toSide":"left"},
		{"id":"bdc9a31b6ee895be","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"c031feacc509fa88","toSide":"top"},
		{"id":"b88e062ba86ed724","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"9a6f883bf656f74c","toSide":"top"},
		{"id":"b8554ee9db3088dc","fromNode":"ca6701d92e3cce2f","fromSide":"bottom","toNode":"9a8f807e2027ea35","toSide":"left"},
		{"id":"af2567bb7fe22228","fromNode":"8b8be7d93ead0124","fromSide":"right","toNode":"feee7abd644766bc","toSide":"left"},
		{"id":"98a55e6687da1fd0","fromNode":"9e82b080985382ab","fromSide":"left","toNode":"df725626448e78cc","toSide":"top","color":"#647d67"},
		{"id":"5ee9281d7a69bb0f","fromNode":"78c919429064fc6f","fromSide":"right","toNode":"758c471e7b787cfc","toSide":"left"},
		{"id":"eea47ca56b567149","fromNode":"9e82b080985382ab","fromSide":"right","toNode":"feee7abd644766bc","toSide":"left"},
		{"id":"850a3b903a4e4c96","fromNode":"eccd8ad4f5dc9a06","fromSide":"left","toNode":"4c57d8667ad37e40","toSide":"right"},
		{"id":"02793aff35e48c13","fromNode":"fd29fd560fbd008a","fromSide":"left","toNode":"4c57d8667ad37e40","toSide":"bottom"},
		{"id":"fd4e80cbf18a355e","fromNode":"4c1d9d9e03f47234","fromSide":"right","toNode":"c6f0d7e72aab30b1","toSide":"top","label":"We don't know how\nlong the program is"},
		{"id":"814ac8984f0f9c90","fromNode":"c6f0d7e72aab30b1","fromSide":"bottom","toNode":"c6b159419b34c723","toSide":"top"},
		{"id":"63bfcea37d9ae3fc","fromNode":"96d87c25a3510683","fromSide":"bottom","toNode":"6680dc9676a45531","toSide":"top"},
		{"id":"6cf81f5776bb542d","fromNode":"c6b159419b34c723","fromSide":"right","toNode":"96d87c25a3510683","toSide":"left"},
		{"id":"6d17777fc6cec4ad","fromNode":"6e58683e17c1533a","fromSide":"right","toNode":"d90428f333b70431","toSide":"left"},
		{"id":"d87a2efe5151d547","fromNode":"c6f0d7e72aab30b1","fromSide":"right","toNode":"6e58683e17c1533a","toSide":"left"},
		{"id":"b90bbf1d0b36b09e","fromNode":"96d87c25a3510683","fromSide":"right","toNode":"afe23a5dcd72b3e1","toSide":"top"},
		{"id":"f3386c5eddbcd9e0","fromNode":"afe23a5dcd72b3e1","fromSide":"left","toNode":"8c1490f20de1e1ff","toSide":"right"},
		{"id":"c845e10558abdadd","fromNode":"afe23a5dcd72b3e1","fromSide":"left","toNode":"096e927c812899d7","toSide":"right"},
		{"id":"516fbdffc3bd6a4e","fromNode":"6e58683e17c1533a","fromSide":"right","toNode":"fe8cd6688727d37e","toSide":"left"},
		{"id":"014b42042f14dae0","fromNode":"9e82b080985382ab","fromSide":"bottom","toNode":"c6b159419b34c723","toSide":"top","color":"#5c7699"},
		{"id":"70a5bc647c5896b9","fromNode":"c6f0d7e72aab30b1","fromSide":"bottom","toNode":"6f4ecf75a2c58ee5","toSide":"top"},
		{"id":"0f7d8de5a15975b6","fromNode":"df725626448e78cc","fromSide":"bottom","toNode":"dc891dc86cb67bd0","toSide":"top"},
		{"id":"0c32a159b4a624c9","fromNode":"096e927c812899d7","fromSide":"left","toNode":"a55675caf74efbf9","toSide":"right"},
		{"id":"339481675c99af21","fromNode":"5f99b821dcfca499","fromSide":"left","toNode":"f7671443fe1d893e","toSide":"right"},
		{"id":"6f9fd07927c84beb","fromNode":"cfa6e85c89954ab7","fromSide":"top","toNode":"196dfcdbb93b10c2","toSide":"top"},
		{"id":"3efd3c9ba32085a3","fromNode":"63fd3c8afbd6ca97","fromSide":"right","toNode":"9942cd5a3e45c932","toSide":"left"},
		{"id":"f5b07ed327d336fc","fromNode":"63fd3c8afbd6ca97","fromSide":"right","toNode":"f4b7aee1e4a0cafa","toSide":"top"},
		{"id":"9d758c42755fc2e4","fromNode":"360a78b7ed2af6ec","fromSide":"top","toNode":"51dcb14aa87c7829","toSide":"left"},
		{"id":"039695e8f3d82cce","fromNode":"63fd3c8afbd6ca97","fromSide":"top","toNode":"360a78b7ed2af6ec","toSide":"left"},
		{"id":"52e15c4311976878","fromNode":"9942cd5a3e45c932","fromSide":"bottom","toNode":"e1da1180115d6c63","toSide":"left"},
		{"id":"cc98aed5e8500430","fromNode":"25a0ac869a6d9fb1","fromSide":"right","toNode":"db709177aa5b0672","toSide":"left"},
		{"id":"3fc28d599ebee0b6","fromNode":"9942cd5a3e45c932","fromSide":"bottom","toNode":"25a0ac869a6d9fb1","toSide":"left"},
		{"id":"6939e1fe8fa7d618","fromNode":"db709177aa5b0672","fromSide":"right","toNode":"283d04409c01b1e2","toSide":"left"},
		{"id":"7101dafe43345e0b","fromNode":"1cfb214abeb5fe07","fromSide":"right","toNode":"82c880c8f1987027","toSide":"left"},
		{"id":"504a5bfc5335961a","fromNode":"db709177aa5b0672","fromSide":"right","toNode":"1cfb214abeb5fe07","toSide":"left"},
		{"id":"21f51fc3245c49b4","fromNode":"360a78b7ed2af6ec","fromSide":"top","toNode":"2bf491bc31b8e49a","toSide":"bottom"},
		{"id":"54106baac5de9f9b","fromNode":"9942cd5a3e45c932","fromSide":"right","toNode":"ebea7275816b5b8d","toSide":"left"},
		{"id":"eee04ad1f158e82f","fromNode":"ebea7275816b5b8d","fromSide":"top","toNode":"822742faa2a11f9c","toSide":"bottom"},
		{"id":"9dbd433d9b84c1f8","fromNode":"ebea7275816b5b8d","fromSide":"right","toNode":"183b2974b6b5f8dc","toSide":"left"},
		{"id":"434b344765bfee12","fromNode":"183b2974b6b5f8dc","fromSide":"bottom","toNode":"10675fa40d5e4625","toSide":"top"},
		{"id":"40564a1179c74696","fromNode":"183b2974b6b5f8dc","fromSide":"top","toNode":"eb6aadb23ef2f8da","toSide":"bottom"},
		{"id":"c93a3480a86dbbc5","fromNode":"183b2974b6b5f8dc","fromSide":"right","toNode":"532f436e32012539","toSide":"left"},
		{"id":"053810556979a0e0","fromNode":"183b2974b6b5f8dc","fromSide":"right","toNode":"16555231db480eb5","toSide":"left"},
		{"id":"a8e65b29a3d6c400","fromNode":"183b2974b6b5f8dc","fromSide":"top","toNode":"d687a10937a9f7a6","toSide":"bottom"},
		{"id":"030bdc170dd76cf6","fromNode":"c77fa3b99749eb74","fromSide":"right","toNode":"e1f1fee65bbe6c9f","toSide":"left"},
		{"id":"8456bad6e9215ad3","fromNode":"e1f1fee65bbe6c9f","fromSide":"right","toNode":"babc668b9decf0e4","toSide":"bottom"},
		{"id":"5ff3706daceb4578","fromNode":"e1f1fee65bbe6c9f","fromSide":"bottom","toNode":"63c506a61d938daa","toSide":"top"},
		{"id":"04799b6e6c85b8f1","fromNode":"e1f1fee65bbe6c9f","fromSide":"bottom","toNode":"36d1db4a6e32f283","toSide":"top"},
		{"id":"78cbb0a75b7d63cb","fromNode":"36d1db4a6e32f283","fromSide":"left","toNode":"101491227211c031","toSide":"bottom"},
		{"id":"afea9fe542e7874f","fromNode":"e1f1fee65bbe6c9f","fromSide":"right","toNode":"ae7b55330412dd52","toSide":"left"},
		{"id":"02bb4da4e2ba0682","fromNode":"ae7b55330412dd52","fromSide":"bottom","toNode":"36c75faac37d20eb","toSide":"top"},
		{"id":"8d9c5dd5bde910ac","fromNode":"63c506a61d938daa","fromSide":"right","toNode":"36c75faac37d20eb","toSide":"left"},
		{"id":"1781d5e1c5274854","fromNode":"e1f1fee65bbe6c9f","fromSide":"right","toNode":"ca20f6b9245bae4d","toSide":"top"},
		{"id":"d5914b028cfc75b9","fromNode":"e1f1fee65bbe6c9f","fromSide":"top","toNode":"2a4f5977ed914c94","toSide":"bottom"},
		{"id":"302fde0429203b1b","fromNode":"e1f1fee65bbe6c9f","fromSide":"right","toNode":"b1719b04b87456d5","toSide":"left"},
		{"id":"25c4e3bbaaa85474","fromNode":"b1719b04b87456d5","fromSide":"top","toNode":"2e521f4a4084d5c0","toSide":"bottom"},
		{"id":"9ea6cd27c9870b65","fromNode":"b1719b04b87456d5","fromSide":"right","toNode":"66214e9b372b8cd1","toSide":"bottom"},
		{"id":"4c13879b08e81f20","fromNode":"d687a10937a9f7a6","fromSide":"right","toNode":"45eadb9ab231dafd","toSide":"top"},
		{"id":"08de789a2bc0a31f","fromNode":"b1719b04b87456d5","fromSide":"right","toNode":"31b61ed25585201a","toSide":"left"},
		{"id":"92678f07f0bf0c1f","fromNode":"2e60b072308d24fd","fromSide":"top","toNode":"85b2461f4596ed9f","toSide":"left"},
		{"id":"2a8c53a5b5239617","fromNode":"c77fa3b99749eb74","fromSide":"top","toNode":"85b2461f4596ed9f","toSide":"bottom"},
		{"id":"680d4cdf34c0562e","fromNode":"b1719b04b87456d5","fromSide":"right","toNode":"0afd602a516ad989","toSide":"left"},
		{"id":"a6a7872e528558d0","fromNode":"0afd602a516ad989","fromSide":"bottom","toNode":"26097e3fc488592d","toSide":"top"},
		{"id":"3a0a2c2c93c392ae","fromNode":"0afd602a516ad989","fromSide":"bottom","toNode":"b6b7c13517422d93","toSide":"top"},
		{"id":"49287a10713c3ce0","fromNode":"0afd602a516ad989","fromSide":"bottom","toNode":"66fd6bafa4582d3f","toSide":"top"},
		{"id":"09b0efc80787cdb0","fromNode":"66fd6bafa4582d3f","fromSide":"bottom","toNode":"675f60f1ff65696a","toSide":"top"},
		{"id":"b8bd785c72e689ef","fromNode":"0afd602a516ad989","fromSide":"right","toNode":"bfe5a5cfb145f461","toSide":"left"},
		{"id":"51de9f35dbb16046","fromNode":"0afd602a516ad989","fromSide":"top","toNode":"b389bd8b0c7b2337","toSide":"bottom"},
		{"id":"7afc07aeacd129b0","fromNode":"b389bd8b0c7b2337","fromSide":"top","toNode":"606f8c3bb3ce86b4","toSide":"bottom"},
		{"id":"db26d0838f5a3229","fromNode":"606f8c3bb3ce86b4","fromSide":"top","toNode":"bd3b934b59d79d51","toSide":"bottom"},
		{"id":"124a8f6074d037f9","fromNode":"b389bd8b0c7b2337","fromSide":"top","toNode":"c452dd0006d3ee65","toSide":"bottom"},
		{"id":"6132551eaeeb77c8","fromNode":"b389bd8b0c7b2337","fromSide":"top","toNode":"4cfb9664e2ae84d0","toSide":"bottom"},
		{"id":"7a0d9d15752d6115","fromNode":"514400a8e034066c","fromSide":"right","toNode":"f03a356f52412cfe","toSide":"left"},
		{"id":"30f12877b8209f2e","fromNode":"b389bd8b0c7b2337","fromSide":"right","toNode":"514400a8e034066c","toSide":"left"},
		{"id":"53d87cba16e9ee09","fromNode":"b389bd8b0c7b2337","fromSide":"right","toNode":"f498518009b9c116","toSide":"left"},
		{"id":"950aede9ec1486a4","fromNode":"ded38139fde28736","fromSide":"top","toNode":"5361d530e4d33f56","toSide":"bottom"},
		{"id":"bc9f4343ce2195ab","fromNode":"ded38139fde28736","fromSide":"right","toNode":"d0677741a0602f0c","toSide":"left"},
		{"id":"558fde5749a273ef","fromNode":"42d8f92d8581a2c9","fromSide":"left","toNode":"d0677741a0602f0c","toSide":"right","label":"Input"},
		{"id":"31e2e86af4119fe3","fromNode":"42d8f92d8581a2c9","fromSide":"bottom","toNode":"51a4b85f34ac38e8","toSide":"top"},
		{"id":"9aacf90ae40c83d4","fromNode":"66fd6bafa4582d3f","fromSide":"right","toNode":"b508da066057940d","toSide":"left"},
		{"id":"9132dcd21e9b50f1","fromNode":"bfc7aaa39082d489","fromSide":"right","toNode":"51a4b85f34ac38e8","toSide":"left"},
		{"id":"5e4a47b568ed38dc","fromNode":"d0677741a0602f0c","fromSide":"bottom","toNode":"bfc7aaa39082d489","toSide":"top"},
		{"id":"d2849db2f0b50b28","fromNode":"d0677741a0602f0c","fromSide":"top","toNode":"1821c33ae57db413","toSide":"bottom"},
		{"id":"413a2b6afa8e576f","fromNode":"1821c33ae57db413","fromSide":"left","toNode":"458eb9912b83c812","toSide":"bottom"},
		{"id":"148eaac50e1eca4b","fromNode":"458eb9912b83c812","fromSide":"top","toNode":"1beb041b3f5eef50","toSide":"bottom"},
		{"id":"c7bb8b88ef962126","fromNode":"ded38139fde28736","fromSide":"left","toNode":"7753127ed80322a8","toSide":"right"},
		{"id":"930e21a4fe34adc0","fromNode":"ded38139fde28736","fromSide":"bottom","toNode":"92e3e91985959c8f","toSide":"top"}
	]
}